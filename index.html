
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>BLOG - Blackskygg&#39;s LOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Blackskygg&apos;s LOG">
<meta property="og:type" content="website">
<meta property="og:title" content="BLOG - Blackskygg's LOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BLOG - Blackskygg's LOG">
<meta property="og:description" content="Blackskygg&apos;s LOG">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BLOG - Blackskygg's LOG">
<meta name="twitter:description" content="Blackskygg&apos;s LOG">
  
    <link rel="alternative" href="/atom.xml" title="BLOG - Blackskygg&#39;s LOG" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  <link href="//fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <!--[if lt IE 9]><script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7/html5shiv.min.js"></script><![endif]-->
  
</head>
<body>
<div id="container">
  <div id="wrap">
    <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BLOG - Blackskygg&#39;s LOG</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="http://www.baidu.com/baidu" method="get" accept-charset="utf-8" class="search-form">
          <input type="search" name="word" maxlength="20" class="search-form-input" placeholder="Search">
          <input type="submit" value="" class="search-form-submit">
          <input name=tn type=hidden value="bds">
          <input name=cl type=hidden value="3">
          <input name=ct type=hidden value="2097152">
          <input type="hidden" name="si" value="yoursite.com">
        </form>
      </div>
    </div>
  </div>
</header>
    <div class="outer">
      <section id="main">
  
    <article id="post-x86-mem-virtualization" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/x86-mem-virtualization/" class="article-date">
  <time datetime="2016-08-17T14:13:07.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/x86-mem-virtualization/">x86内存虚拟化技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="内存虚拟化会带来的问题"><a href="#内存虚拟化会带来的问题" class="headerlink" title="内存虚拟化会带来的问题"></a>内存虚拟化会带来的问题</h2><hr>
<ul>
<li>ring aliasing</li>
<li>ring compression</li>
<li>需两次转换，而MMU仅能执行一次转换</li>
<li>GOS和HOS频繁切换导致的TLB失效</li>
<li>安全方面，必须保证各个域之间的隔离，以及GOS和HOS空间的隔离（address compression）</li>
</ul>
<h2 id="MMU半虚拟化"><a href="#MMU半虚拟化" class="headerlink" title="MMU半虚拟化"></a>MMU半虚拟化</h2><hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>由VMM在其中牵线搭桥，将中间地址层（客户物理地址）通过由VMM保管的一个转换表（机器地址–&gt;客户物理地址）消除。也就是说，经过VMM的努力后，GOS所拥有的客户页表中的地址不再是客户物理地址，而是机器地址，因此MMU能够像在原来操作系统中一样直接完成由虚拟地址到机器地址的转换工作。</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>效率高，但需要修改内核。</p>
<h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>通过分段，分页机制将GOS和VMM的空间隔离，保证了GOS和VMM的隔离之后，VMM便是可信任的，故可以通过VMM空间中的P2M来控制访问权限，进而将GOS之间隔离。异常可以通过hypercall机制来被VMM感知并处理。</p>
<h2 id="影子页表（Shadow-Page-Table）"><a href="#影子页表（Shadow-Page-Table）" class="headerlink" title="影子页表（Shadow Page Table）"></a>影子页表（Shadow Page Table）</h2><hr>
<h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>在全虚拟化或引入硬件虚拟化的虚拟机系统中，对于没有修改过系统内核的GOS，其虚拟地址到机器地址的转换必须使用影子页表（Shadow Page Table）来实现。为了能够消除客户物理地址层，使得MMU能够利用剩下的虚拟地址和机器地址完成地址转换。与半虚拟化技术将这个映射关系更新到GOS 的页表项不同，影子页表技术则是为GOS 的每个页表维护一个“影子页表”，并将合成后的映射关系（虚拟地址–&gt;机器地址）写入到这个“影子页表”中，GOS 的页表内容则保持不变。最后，VMM 将影子页表交给MMU 进行地址转换。</p>
<h3 id="安全-1"><a href="#安全-1" class="headerlink" title="安全"></a>安全</h3><p>与上一种方法大体相同，只是访问控制改为由影子页表控制。大部分的异常监控仍然由软件完成。</p>
<h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><p>不需要修改内核，但是效率低下。<br>首先是时间开销，由于GOS 构造页表时不会主动通知VMM，VMM 必须等到GOS 发生缺页时通过分析缺页原因，再为其补全影子页表。此过程中VMM 需要通过模拟MMU 遍历GOS的页表，方能获得GOS 所维护的地址映射关系（虚拟地址–&gt;客户物理地址），这种间接的手段要比半虚拟化低效很多。另外，由于每次缺页都会造成上下文切换，会导致TLB频繁失效，造成更大的性能损失。<br>其次是空间开销，VMM 需要支持多个虚拟机同时运行，而每个虚拟机的GOS 通常会为其上运行的每个进程都创建一套页表系统，因此影子页表的空间开销会随着进程的数量的增多而迅速增大，而GOS 的进程数量是VMM不可控的。减小空间开销的一种方法是只为当前进程的页表维护影子页表，这样做虽然将空间开销限制在了常数级别，但是却大大增加了上下文切换的时间开销：VMM 需要在GOS 的每个进程切换时重构新进程的所有影子页表。在空间开销和时间开销中做出权衡的方法是使用影子页表缓存（Shadow Page Table Cache），即VMM 在内存中维护部分最近使用过的影子页表，只有当影子页表在缓存中找不到时，才构建一个新的，但仍然不能有一个质的改变。</p>
<h2 id="硬件虚拟化（VT-x）"><a href="#硬件虚拟化（VT-x）" class="headerlink" title="硬件虚拟化（VT-x）"></a>硬件虚拟化（VT-x）</h2><hr>
<h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>VMX指令集通过引入了一个可以由VMM通过VMCS来监控其各种行为的非根操作环境（non-root）来解决CPU虚拟化中ring aliasing和ring compression的问题，提供了陷入机制，可以监控各种敏感指令。由于这部分由硬件实现，故大大提高了效率。<br>对内存虚拟化的支持：引入了EPT（extended page table）。<br>EPT 技术在原有客户机页表对客户机虚拟地址到客户机物理地址映射的基础上，又引入了 EPT 页表来实现客户机物理地址到宿主机物理地址的另一次映射，这两次地址映射都是由硬件自动完成。客户机运行时，客户机页表被载入 CR3，而 EPT 页表被载入专门的 EPT 页表指针寄存器 EPTP。EPT 页表对地址的映射机理与客户机页表对地址的映射机理相同，下图 1 出示了一个页面大小为 4K 的映射过程：</p>
<p><img src="https://app.yinxiang.com/shard/s58/res/64a73118-6e8b-419d-bf0f-83eea2cb780c"></p>
<p>图 1.EPT 页表转换</p>
<p>在客户机物理地址到宿主机物理地址转换的过程中，由于缺页、写权限不足等原因也会导致客户机退出，产生 EPT 异常。对于 EPT 缺页异常，KVM 首先根据引起异常的客户机物理地址，映射到对应的宿主机虚拟地址，然后为此虚拟地址分配新的物理页，最后 KVM 再更新 EPT 页表，建立起引起异常的客户机物理地址到宿主机物理地址之间的映射。对 EPT 写权限引起的异常，KVM 则通过更新相应的 EPT 页表来解决。<br>此外VT-x技术还引入了VCPUID的概念，实现了带tag的TLB，降低了由TLB失效所带来的性能损失。</p>
<h3 id="安全-2"><a href="#安全-2" class="headerlink" title="安全"></a>安全</h3><p>异常的监控与捕获很大程度上交给了速度较快的硬件。由硬件来监控GOS的异常行为，由于硬件与软件之间存在天然的隔离，故硬件的监控是可信任的，在监控能到异常之后，会将控制权交由VMM来采取相应的措施。总的来说，是在软硬件天然隔离的基础上保证了软件与硬件的协作监控的可信。而这个协作监控，又保证了其上GOS之间，以及VMM与GOS之间的有效隔离。</p>
<h3 id="效率-2"><a href="#效率-2" class="headerlink" title="效率"></a>效率</h3><p>解决了三层地址的转换问题，避免了频繁的GOS和HOS上下文切换，且访问控制也由硬件监控。在TLB中引入了VCPUID，即带tag的TLB，可以减少因TLB失效而带来的性能损失。但是相应地，一旦发生TLB miss，其开销会非常大，因为硬件必须走过两个完整的页表结构。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/08/17/x86-mem-virtualization/" data-id="cirz0dvoe0004eznie8f3k8kr" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/2016/08/17/x86-mem-virtualization/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-virtio-host-guest-communication" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/virtio-host-guest-communication/" class="article-date">
  <time datetime="2016-08-17T14:02:30.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/virtio-host-guest-communication/">使用virtio-serial实现guest OS与host的高效通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Virtio简介"><a href="#Virtio简介" class="headerlink" title="Virtio简介"></a>Virtio简介</h2><hr>
<p>virtio是kvm/Linux中的io半虚拟化解决方案，其前端驱动运行在Guest OS的内核中，且已经被整合入Linux Kernel. 其后端驱动运行在qemu中负责接处理来自前端驱动的IO请求。由于virtio使用的是半虚拟化机制，使用virtio进行io可以达到几乎接近native的性能。目前virtio已经成为kvm<br>具体介绍可以查看：<br><a href="http://www.ibm.com/developerworks/cn/linux/l-virtio/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/l-virtio/</a><br><a href="http://www.ibm.com/developerworks/cn/linux/1402_caobb_virtio/" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/linux/1402_caobb_virtio/</a><br><a href="http://www.linux-kvm.org/page/Virtio/" target="_blank" rel="external">http://www.linux-kvm.org/page/Virtio/</a></p>
<h2 id="Virtio-serial简介"><a href="#Virtio-serial简介" class="headerlink" title="Virtio-serial简介"></a>Virtio-serial简介</h2><hr>
<p>virtio有一种有趣的应用：用于实现Guest与Host的高效通信。可以通过在Guest中虚拟出一个虚拟串口，并将该串口通过qemu上的后端驱动，经由host上的IPC机制，暴露给host上的其它应用。这样可以方便的实现Guest与Host之间的高效通信。该方式相对基于网络通信方式来说，具有效率高（没有封包解包过程），占用资源少，安全性高的优点。<br>可以参照：<br><a href="http://blog.csdn.net/hbsong75/article/details/9451929" target="_blank" rel="external">http://blog.csdn.net/hbsong75/article/details/9451929</a></p>
<h2 id="Libvirt简介"><a href="#Libvirt简介" class="headerlink" title="Libvirt简介"></a>Libvirt简介</h2><hr>
<p>libvirt是一套免费、开源的支持Linux下主流虚拟化工具的C函数库，其旨在为包括Xen在内的各种虚拟化工具提供一套方便、可靠的API。当前主流Linux平台上默认的虚拟化管理工具virt-manager,virt-install等均基于libvirt开发而成。<br>libvirt 库是一种实现 Linux 虚拟化功能的 Linux API，它支持各种虚拟机监控程序，包括 Xen 和 KVM，以及 QEMU 和用于其他操作系统的一些虚拟产品。他对各种不同的hypervisor提供了较为统一的管理方式以及API。<br>libvirt使用xml来对各个域进行描述，具体到当前的目标，我们可以通过在xml中添加virtio-serial的方式来在guest中创建虚拟串口。此外，libvirt还支持由qemu的命令行参数生成相应的xml，因此由现有qemu虚拟机创建一个libvirt域是非常方便的。一有了描述域的xml之后，便可以通过libvirt的命令行管理工具virsh来创建，启动，停止该域。<br>详情可见libvirt官网：<br><a href="http://libvirt.org/" target="_blank" rel="external">http://libvirt.org/</a></p>
<h2 id="AF-UNIX-socket简介"><a href="#AF-UNIX-socket简介" class="headerlink" title="AF_UNIX socket简介"></a>AF_UNIX socket简介</h2><hr>
<p>通过libvirt的channel机制可以将guest里面的串口映射到host中的一个AF_UNIX socket文件中。<br>AF_UNIX类型的socket实质上是一种本机的IPC机制，其工作方式为直接将一个进程的用户空间数据copy到另一个进程的空间中，是一种效率很高的IPC。<br>可以参考:<br><a href="https://en.wikipedia.org/wiki/Unix_domain_socket" target="_blank" rel="external">https://en.wikipedia.org/wiki/Unix_domain_socket</a><br><a href="http://man7.org/linux/man-pages/man7/unix.7.html" target="_blank" rel="external">http://man7.org/linux/man-pages/man7/unix.7.html</a></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><hr>
<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><p>源码编译qemu（典型的./configure;make;make install过程，附带解决一些确实的依赖，都是routine），编译时按需打开相应支持，并在qemu上安装好一个ubuntu 14.04 LTS。<br>安装libvirt:<br>     从git获取源码 git clone git://libvirt.org/libvirt.git<br>    执行./autogen。若出现错误，则根据错误提示安装缺失的相应依赖（印象中有perl的XML::XML_Parser，libdevmap-dev, libxml2-dev等等，依赖较多，需要些耐心，不过都是些routine）<br>    然后便是常规的make -j<code>nproc</code>; sudo make install</p>
<h3 id="创建libvirt域"><a href="#创建libvirt域" class="headerlink" title="创建libvirt域"></a>创建libvirt域</h3><p>工作目录为/home/ubuntu/vms/，ubuntu_img是硬盘镜像文件</p>
<p>把qemu的参数写到一个文件里面<br>    echo “/usr/local/bin/qemu-system-x86_64 -m 512 –drive file=/home/ubuntu/vms/ubuntu_img,format=raw,index=0,media=disk –boot order=d –enable-kvm” &gt; qemu.args</p>
<p>从该文件创建xml<br>    virsh domxml-from-native qemu-argv qemu.args &gt; vm1.xml</p>
<p>修改域的名字<br>    <name>vm1</name></p>
<p>修改图形显示为vnc方式（不知道为什么libvirt认不出type=’gtk’， 所以只好用vnc了）<br>    <graphics type="vnc" port="5900"></graphics></p>
<p>并添加两个channel，将virtio-serial映射为host上的两个AF_UNIX socket文件, vm.ctl和vm.data</p>
<pre><code>&lt;channel type=&apos;unix&apos;&gt;
&lt;source mode=&apos;bind&apos; path=&apos;/home/ubuntu/vms/vm.ctl&apos;/&gt;
&lt;target type=&apos;virtio&apos; address=&apos;virtio-serial&apos; port=&apos;0&apos;/&gt;
&lt;/channel&gt;

&lt;channel type=&apos;unix&apos;&gt;
&lt;source mode=&apos;bind&apos; path=&apos;/home/ubuntu/vms/vm.data&apos; /&gt;
&lt;target type=&apos;virtio&apos; address=&apos;virtio-serial&apos; port=&apos;1&apos; /&gt;
&lt;/channel&gt;

&lt;controller type=&apos;virtio-serial&apos; index=&apos;0&apos; ports=&apos;16&apos; /&gt;
</code></pre><p>创建并启动vm1<br>    virsh create vm1.xml</p>
<h2 id="实现通信"><a href="#实现通信" class="headerlink" title="实现通信"></a>实现通信</h2><p>用remmina（或者其它vnc客户端）连上去之后，可以发现在guest的/dev 下有如下两个文件<br>vport0p1 vport0p2<br>可以直接通过文件io来读写，我们尝试一下往vport0p1里面写字符串，看主机能否收到<br>这是客户端的代码，运行时要记得加sudo，因为该程序直接读写了设备文件</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
     int fd0;
     char *greetings = &quot;Hi there!\n&quot;;

     fd0 = open(&quot;/dev/vport0p1&quot;, O_RDWR);
     for(;;) {
         write(fd0, greetings, strlen(greetings) + 1);
         sleep(1);                                                                     //一秒写一次
     }

     return 0;
}
</code></pre><p>这是host端的代码，用来通过UNIX domain socket接收从guest中发来的消息，这里我们尝试一下读vport0p1对应的vm.ctl</p>
<pre><code>#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/un.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main()
{
    int sock;
    struct sockaddr_un addr;      // AF_UNIX的地址结构是sockaddr_un
    char buffer[512];

    sock = socket(AF_UNIX, SOCK_STREAM, 0);  //创建一个 UNIX domain socket
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, &quot;vm.ctl&quot;);

    if(-1 == connect(sock, (struct sockaddr *)&amp;addr, sizeof(addr)))
        perror(&quot;aha:&quot;);

    while(read(sock, buffer, 512)) {
        printf(&quot;data: %s\n&quot;, buffer);
        getchar();
    }

    return 0;
}
</code></pre><p>运行之后，敲击一次回车可以看到一条信息，说明信道畅通。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/08/17/virtio-host-guest-communication/" data-id="cirz0dvod0003ezni3ddlsb1n" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/2016/08/17/virtio-host-guest-communication/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Virtualization/">Virtualization</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-buffer-over-flow" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/buffer-over-flow/" class="article-date">
  <time datetime="2016-08-17T13:56:17.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/buffer-over-flow/">Buffer Over Flow</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>This is not a passage, but just some pieces of reminders.</p>
<h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><hr>
<p>A buffer overflow happens when more data is written to or read from a buffer than the buffer can hold.</p>
<h2 id="real-examples"><a href="#real-examples" class="headerlink" title="real examples"></a>real examples</h2><hr>
<p>In fact the first self-propagating Internet worm—1988’s Morris Worm—used a buffer overflow in the Unix finger daemon to spread from machine to machine.<br>And just this May, a buffer overflow found in a Linux driver left (potentially) millions of home and small office routers vulnerable to attack.<br>heart-bleed</p>
<h2 id="stack-it-up"><a href="#stack-it-up" class="headerlink" title="stack it up"></a>stack it up</h2><hr>
<p>function have address, which are almost fixed<br>the memory layout of a program, virtual address, libs, kernel space, and so on<br>esp, eip, ebp, return address and so on<br>code inject, shell code</p>
<h2 id="an-attacker’s-toolkit"><a href="#an-attacker’s-toolkit" class="headerlink" title="an attacker’s toolkit"></a>an attacker’s toolkit</h2><hr>
<p>instructions can contain zero-bytes : convert into equivalent sequences that avoid the problem byte<br>return address can contain zero-bytes(because they always lay in the lower part of the address space) : use “call esp” from elsewhere, may from the library or other functions(trampolining)<br>“NOP sled”</p>
<h2 id="blame-c"><a href="#blame-c" class="headerlink" title="blame c"></a>blame c</h2><hr>
<p>gets(), strcpy(), strcat() and even strncpy(), strncat() are unsafe</p>
<h2 id="Fixing-the-leaks"><a href="#Fixing-the-leaks" class="headerlink" title="Fixing the leaks"></a>Fixing the leaks</h2><hr>
<p>safe runtime environments<br>lots of awful c code still in use:legacy, performance, low level operations, many libs depends on C(even C# and friends)<br>and so are buffer overflows<br>some tools to analyze source code and running programs :<br> AddressSantizer  Valgrind, but they require active involvement of the developer<br>some systems to make it harder to exploit overflows :<br>W^X (“write exclusive-or execute”), DEP (“data execution prevention”), NX (“No Xecute”), XD (“eXecute Disable”), EVP (“Enhanced Virus Protection,” a rather peculiar term sometimes used by AMD), XN (“eXecute Never”), efficient and cost little, can be complemented by hardware, can be applied to existing programs retroactively just by updating the operating system to one that supports it(although hard for things like JVM and .NET), has been mainstream since 2004</p>
<h2 id="Beyond-NX"><a href="#Beyond-NX" class="headerlink" title="Beyond NX"></a>Beyond NX</h2><hr>
<p>system()(the so-called return-to-libc technique) : useful , but sometimes system() don’t take arguments from stacks, and calling multiple function is hard<br>a number of ways to extend return-to-libc : nonetheless limited<br>return-oriented-programming (ROP) : using gadgets , each gadget follows a particular pattern: it performs some operation (putting a value in a register, writing to memory, adding two registers, etc.) followed by a return instruction, some times you can find a Turing-complete set of these, these instructions can even be used to change the current state of the pages, turning them into excutable</p>
<h2 id="Getting-random"><a href="#Getting-random" class="headerlink" title="Getting random"></a>Getting random</h2><hr>
<p>Address Space Layout Randomization (ASLR) : it randomizes the position of the stack and the in-memory location of libraries and executables<br>it’s useful but hard to apply to current systems : it’s ok for dlls, but hard for linux and exes, (compatibility, performance)<br>but the range the address can be is limited on x86 : total memory is limited, libs must stay as close as they can, code always start at the beginning of a page, etc<br>thus, if the chance is 1/256, you can try it out for 256 times and you’ll succeed<br>the situation is better on x64, guessing is almost impossible<br>browsers : javascript, flash(both contain JIT), PDF plugin, Microsoft’s Office browser plugins(old version didn’t enable ASLR)<br>A never-ending war<br>Powerful protective systems such as ASLR and NX raise the bar for taking advantage of flaws and together have put the days of the simple stack buffer overflow behind us, but smart attackers can still combine multiple flaws to defeat these protections.<br>Microsoft’s EMET (“Enhanced Mitigation Experience Toolkit”) includes a range of semi-experimental protections that try to detect heap spraying or attempts to call certain critical functions in ROP-based exploits. But in the continuing digital arms war, even these have security techniques that have been defeated.<br>the difficulty (and hence cost) of exploiting flaws goes up with each new mitigation technique—but it’s a reminder of the need for constant vigilance.</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/08/17/buffer-over-flow/" data-id="cirz0dvo20000ezni1aok8tmk" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/2016/08/17/buffer-over-flow/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Pieces/">Pieces</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Software-Security/">Software Security</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-gallon-jugs-and-euclid" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/17/gallon-jugs-and-euclid/" class="article-date">
  <time datetime="2016-08-17T09:28:03.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/gallon-jugs-and-euclid/">倒水问题与欧几里德</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个系列是MIT Open Courseware Mathematics for Computer Science<a href="http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/" target="_blank" rel="external">^1</a>的记录</p>
<h2 id="倒水问题"><a href="#倒水问题" class="headerlink" title="倒水问题"></a>倒水问题</h2><hr>
<p>有这么一个游戏：有两个桶a和b,容量分别是3 gal和5 gal,然后让你用这两个桶量出4 gal水来.如果用(a中剩余的水, b中剩余的水)来表示一个状态的话,整个过程表述如下:<br>$$(0, 0)\rightarrow(3, 0)\rightarrow(0, 3)\rightarrow(3, 3)\rightarrow(1, 5)\rightarrow(1, 0)\rightarrow(0, 1)\rightarrow(3, 1)\rightarrow(0, 4)$$</p>
<p>但是如果把a和b的容量换成3 gal和6 gal呢,还能量出刚好4 gal吗？直觉告诉我们不能.接下来为这个直觉寻找理论依据.</p>
<h2 id="问题的形式化描述"><a href="#问题的形式化描述" class="headerlink" title="问题的形式化描述"></a>问题的形式化描述</h2><hr>
<p>对于上述的问题, 我们先对其进行形式化：</p>
<blockquote>
<p>$给定两个桶a,b,桶a的容量为va,桶b的容量为vb. 且假定va \leq vb.$<br>$可以进行的操作有：清空一个桶,填满一个桶和将一个桶的水倒入另一个桶中.$<br>$以(x,y)记某个时刻的状态,表示a桶中有x \space gal水, b桶中有y \space gal水.$<br>$对与一个给定的数字r(0 \leq r \leq vb),能否达到某个状态(x’,y’), 使得r = x’ \land r = y’?$</p>
</blockquote>
<p>于是,整个过程是一个状态机,其起始状态为(0,0).可能的转换描述如下:</p>
<blockquote>
<ul>
<li>$(x,y)\rightarrow(va,x).$</li>
<li>$(x,y)\rightarrow(x,vb).$</li>
<li>$(x,y)\rightarrow(0,y).$</li>
<li>$(x,y)\rightarrow(x,0).$</li>
<li>$(x,y)\rightarrow(x+y-vb,vb), if \space x+y \geq vb$</li>
<li>$(x,y)\rightarrow(0,x+y), if \space x+y \leq vb$</li>
<li>$(x,y)\rightarrow(va,x+y-va), if \space x+y \geq va$</li>
<li>$(x,y)\rightarrow(x+y,0), if \space x+y \leq va$</li>
</ul>
</blockquote>
<h2 id="问题的几个结论"><a href="#问题的几个结论" class="headerlink" title="问题的几个结论"></a>问题的几个结论</h2><hr>
<blockquote>
<p>$定理1: \forall k \forall(x,y)(k|va \land k|vb \rightarrow k|x \land k|y).$</p>
</blockquote>
<p>可以很简单地用归纳法对以下invariant进行证明.</p>
<blockquote>
<p>$P(n): (x,y)为n轮转换后的状态 \rightarrow k|x \land k|y.$</p>
</blockquote>
<p>(0,0)时显然成立,下面证对于转换$(x,y)\rightarrow(x+y-vb,vb), if \space x+y \geq vb$成立,其余类似.</p>
<p>$let \space (x’,y’) \space be \space the \space next \space state$<br>$x’=x+y-vb, y’=vb$<br>$k|vb \implies k|y’$<br>$k|vb, k|x, k|y \implies k|x+y-vb \implies k|x’$<br>$P(n) \space holds$</p>
<p>定理1得证.<br>于是,对于$va=3,vb=6,r=4$的情况,由于对于任何$(x,y)$都有$3|x \land 3|y$,故不可能有$x=4 \lor y=4$的状态.<br>那么能否描述出可能达到的状态所满足的性质呢.答案是肯定的首先可以确定的是所有状态$(x,y)$, 都满足x和y都是va,vb的线性组合,这是显然的.其次,有如下事实.</p>
<blockquote>
<p>$定理2: 所有va和vb的线性组合l1和l2(0 \leq l1, l2 \leq vb)所组成的状态(l1, l2)都是可到达的.$</p>
</blockquote>
<p>首先,注意到对于任意的$l=p \times va + q \times vb(0 \leq l \leq vb)$, 无论p的正负, 都有办法写成$l=p’ \times va + q’ \times vb, p \gt 0$的形式.<br>理由如下：<br>对于$l=p \times va + q \times vb$,有$l=(p + m \times vb)\times va+(q-m \times va) \times vb$.<br>于是可以通过调整m的大小来将$p’=p + m \times vb$变为正数.<br>而对于$l=p’ \times va + q’ \times vb, p \gt 0$, 可以通过以下算法得到.</p>
<pre><code>for i in [0, p&apos;) {
    fill a;
    while (a is not empty) {
        if b is full {
            empty b;
        }
        pour all the water in a into b;
    }
}
</code></pre><p>设最后的状态为$(x’, y’)$, 不难看出有$x’ = 0 \land y’ = p’ \times va + h \times vb$, 而由于限制条件$(0 \leq l \leq vb)$的存在. 可以得到$h=q’, 故y’ = l$. 目的达到. 定理二得证.</p>
<p>再回到定理1.<br>在众多满足条件的k中,gcd(va, vb)应该算是比较特殊的,而计算gcd(va, vb)的方法中,最常用的就是欧几里德算法.其证明也相对简单（只需证对于$a = p \times b + rem(a,b), 有gcd(a, b) = gcd(p, rem(a,b)$即可）.<br>那么问题来了, gcd(va, vb)是否是va, vb的一个线性组合呢？ 如果是的话. 由于所有va, vb在$(0, vb]$内的线性组合$l$都有$gcd(va,vb)|l$, 故gcd(va, vb)就有了一个新身份:<br>va, vb的最小正线性组合！<br>事实是不仅有, 而且还能很方便的算出线性组合系数,这个计算的方法,就是扩展欧几里德算法.</p>
<h2 id="扩展欧几里德"><a href="#扩展欧几里德" class="headerlink" title="扩展欧几里德"></a>扩展欧几里德</h2><hr>
<p>首先还是来证明一下这一点:</p>
<blockquote>
<p>$定理3:gcd(a,b)是a,b的一个线性组合.$</p>
</blockquote>
<p>首先来证明:</p>
<blockquote>
<p>$如果x, y都是a和b的线性组合, 那么rem(x, y)也是a和b的线性组合$</p>
</blockquote>
<p>这很显然：</p>
<blockquote>
<p>$令x=p1 \times a+q1 \times b, y=p2 \times a+q2 \times b$<br>$令x = k \times y + rem(x,y)$<br>$有rem(x,y) = x - k \times y \implies rem(x,y)=p1 \times a+q1 \times b -k \times p2 \times a - k \times q2 \times b$<br>$\implies rem(x,y)=(p1 - k \times p2) \times a + (q1 - k \times q2) \times b$<br>$\implies rem(x,y)为a和b的线性组合$</p>
</blockquote>
<p>也就是说在欧几里德算法计算出的序列$(a, b)\rightarrow(b, rem(b,a))\rightarrow\cdots\rightarrow(x,y)\rightarrow\cdots\rightarrow(rem(t1, t2), 0)$中.<br>由归纳法可知，对于任意一个中间结果$(x, y)$，都有x和y是b的线性组合. 而最终的结果$rem(t1, t2) = gcd(a, b)$, 自然也是a和b的一个线性组合.<br>至于扩展欧几里德算法本身，已经包含在上面的证明中了。</p>

      
    </div>
    <footer class="article-footer">
      
        <a data-url="http://yoursite.com/2016/08/17/gallon-jugs-and-euclid/" data-id="cirz0dvo70001eznip4s8qs7o" class="article-share-link">分享到</a>
      

      
        <a href="http://yoursite.com/2016/08/17/gallon-jugs-and-euclid/#ds-thread" class="article-comment-link">评论</a>
      

      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mathematics-for-Computer-Science/">Mathematics for Computer Science</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Number-Theory/">Number Theory</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
</section>
      
      <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Mathematics-for-Computer-Science/">Mathematics for Computer Science</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Number-Theory/">Number Theory</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Pieces/">Pieces</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Software-Security/">Software Security</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Virtualization/">Virtualization</a><span class="tag-list-count">2</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Mathematics-for-Computer-Science/" style="font-size: 10px;">Mathematics for Computer Science</a> <a href="/tags/Number-Theory/" style="font-size: 10px;">Number Theory</a> <a href="/tags/Pieces/" style="font-size: 10px;">Pieces</a> <a href="/tags/Software-Security/" style="font-size: 10px;">Software Security</a> <a href="/tags/Virtualization/" style="font-size: 20px;">Virtualization</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">August 2016</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">近期文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/08/17/x86-mem-virtualization/">x86内存虚拟化技术</a>
          </li>
        
          <li>
            <a href="/2016/08/17/virtio-host-guest-communication/">使用virtio-serial实现guest OS与host的高效通信</a>
          </li>
        
          <li>
            <a href="/2016/08/17/buffer-over-flow/">Buffer Over Flow</a>
          </li>
        
          <li>
            <a href="/2016/08/17/gallon-jugs-and-euclid/">倒水问题与欧几里德</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">友情链接</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="https://github.com/blackskygg" target="_blank">blackskygg&#39;s github</a>
          </li>
        
          <li>
            <a href="http://xiguabaobao.com" target="_blank">主题作者</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 blacksygg<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
      .
      Theme by <a href="https://github.com/xiangming/landscape-plus" target="_blank">Landscape-plus</a>
    </div>
  </div>
</footer>
  </div>
  <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
  <!-- totop start -->
<div id="totop">
<a title="返回顶部"><img src="/img/scrollup.png"/></a>
</div>

<!-- totop end -->

<!-- 多说公共js代码 start -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"blackskygg"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
<!-- 多说公共js代码 end -->


<!-- 百度分享 start -->

<!-- 百度分享 end -->

<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>




<! -- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
                processEscapes: true
                    
}
  
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
                  
}
    
        });
</script>

<script type="text/x-mathjax-config">
MathJax.Hub.Queue(function() {
            var all = MathJax.Hub.getAllJax(), i;
            for(i=0; i < all.length; i += 1) {
                            all[i].SourceElement().parentNode.className += ' has-jax';
                                    
            }
                
        });
</script>

<script type="text/javascript" src="http://cdn.bootcss.com/mathjax/2.5.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<script src="/js/script.js"></script>

</div>
</body>
</html>
